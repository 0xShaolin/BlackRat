"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.copyAppFiles = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let copyAppFiles = exports.copyAppFiles = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (fileWalker, fileCopierHelper, unpackedDest) {
        const files = yield fileCopierHelper.collect(fileWalker);
        const metadata = fileWalker.metadata;
        const transformedFiles = fileCopierHelper.transformedFiles;
        // search auto unpacked dir
        const unpackedDirs = new Set();
        const taskManager = new (_asyncTaskManager || _load_asyncTaskManager()).AsyncTaskManager(fileWalker.packager.cancellationToken);
        const dirToCreateForUnpackedFiles = new Set(unpackedDirs);
        const fileCopier = new (_fs || _load_fs()).FileCopier();
        const links = [];
        for (let i = 0, n = files.length; i < n; i++) {
            const file = files[i];
            const stat = metadata.get(file);
            if (stat == null) {
                // dir
                continue;
            }
            const relativePath = file.replace(fileWalker.src, unpackedDest);
            if (stat.isFile()) {
                const fileParent = _path.dirname(file);
                // const dirNode = this.fs.getOrCreateNode(this.getRelativePath(fileParent))
                const newData = transformedFiles == null ? null : transformedFiles[i];
                if (newData != null) {
                    transformedFiles[i] = null;
                }
                if (!dirToCreateForUnpackedFiles.has(fileParent)) {
                    dirToCreateForUnpackedFiles.add(fileParent);
                    yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(fileParent.replace(fileWalker.src, unpackedDest));
                }
                taskManager.addTask((0, (_asarUtil || _load_asarUtil()).copyFileOrData)(fileCopier, newData, file, relativePath, stat));
                if (taskManager.tasks.length > (_fs || _load_fs()).MAX_FILE_REQUESTS) {
                    yield taskManager.awaitTasks();
                }
            } else if (stat.isSymbolicLink()) {
                links.push({ "file": relativePath, "link": yield (0, (_fsExtraP || _load_fsExtraP()).readlink)(file) });
            }
        }
        if (taskManager.tasks.length > (_fs || _load_fs()).MAX_FILE_REQUESTS) {
            yield taskManager.awaitTasks();
        }
        if (links.length > 0) {
            (_bluebirdLst2 || _load_bluebirdLst2()).default.map(links, function (it) {
                return (0, (_fsExtraP || _load_fsExtraP()).symlink)(it.link, it.file);
            }, (_fs || _load_fs()).CONCURRENCY);
        }
    });

    return function copyAppFiles(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
    };
})();
//# sourceMappingURL=appFileCopier.js.map


var _fs;

function _load_fs() {
    return _fs = require("electron-builder-util/out/fs");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _asarUtil;

function _load_asarUtil() {
    return _asarUtil = require("./asarUtil");
}

var _asyncTaskManager;

function _load_asyncTaskManager() {
    return _asyncTaskManager = require("./asyncTaskManager");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }