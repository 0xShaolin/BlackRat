"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.computeDefaultAppDirectory = exports.validateConfig = exports.computeElectronVersion = exports.getElectronVersion = exports.getConfig = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

let loadConfig = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (projectDir, packageMetadata) {
        const data = getConfigFromPackageData(packageMetadata || (yield (0, (_promise || _load_promise()).orNullIfFileNotExist)((0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(projectDir, "package.json")))));
        return data == null ? (0, (_readConfigFile || _load_readConfigFile()).findAndReadConfig)(projectDir, "electron-builder", (_electronBuilderUtil || _load_electronBuilderUtil()).log) : data;
    });

    return function loadConfig(_x, _x2) {
        return _ref.apply(this, arguments);
    };
})();
/** @internal */


let getConfig = exports.getConfig = (() => {
    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (projectDir, configPath, packageMetadata, configFromOptions) {
        let fileOrPackageConfig;
        if (configPath == null) {
            fileOrPackageConfig = yield loadConfig(projectDir, packageMetadata);
        } else {
            fileOrPackageConfig = yield (0, (_readConfigFile || _load_readConfigFile()).readConfig)(_path.resolve(projectDir, configPath), projectDir, (_electronBuilderUtil || _load_electronBuilderUtil()).log);
        }
        const config = (0, (_deepAssign || _load_deepAssign()).deepAssign)(fileOrPackageConfig == null ? Object.create(null) : fileOrPackageConfig, configFromOptions);
        let extendsSpec = config.extends;
        if (extendsSpec == null && extendsSpec !== null && packageMetadata != null) {
            const devDependencies = packageMetadata.devDependencies;
            if (devDependencies != null) {
                if ("react-scripts" in devDependencies) {
                    extendsSpec = "react-cra";
                    config.extends = extendsSpec;
                } else if ("electron-webpack" in devDependencies) {
                    extendsSpec = "electron-webpack/electron-builder.yml";
                    config.extends = extendsSpec;
                }
            }
        }
        if (extendsSpec == null) {
            return config;
        }
        let parentConfig;
        if (extendsSpec === "react-cra") {
            parentConfig = yield (0, (_rectCra || _load_rectCra()).reactCra)(projectDir);
        } else {
            let spec = extendsSpec;
            let isFileSpec;
            if (spec.startsWith("file:")) {
                spec = spec.substring("file:".length);
                isFileSpec = true;
            }
            parentConfig = yield (0, (_promise || _load_promise()).orNullIfFileNotExist)((0, (_readConfigFile || _load_readConfigFile()).readConfig)(_path.resolve(projectDir, spec), projectDir, (_electronBuilderUtil || _load_electronBuilderUtil()).log));
            if (parentConfig == null && isFileSpec !== true) {
                let resolved = null;
                try {
                    resolved = require.resolve(spec);
                } catch (e) {
                    // ignore
                }
                if (resolved != null) {
                    parentConfig = yield (0, (_readConfigFile || _load_readConfigFile()).readConfig)(resolved, projectDir, (_electronBuilderUtil || _load_electronBuilderUtil()).log);
                }
            }
            if (parentConfig == null) {
                throw new Error(`Cannot find parent config file: ${spec}`);
            }
        }
        // electron-webpack and electrify client config - want to exclude some files
        // we add client files configuration to main parent file matcher
        if (parentConfig.files != null && config.files != null && (Array.isArray(config.files) || typeof config.files === "string") && Array.isArray(parentConfig.files) && parentConfig.files.length > 0) {
            const mainFileSet = parentConfig.files[0];
            if (typeof mainFileSet === "object" && (mainFileSet.from == null || mainFileSet.from === ".")) {
                var _mainFileSet$filter;

                mainFileSet.filter = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(mainFileSet.filter);
                (_mainFileSet$filter = mainFileSet.filter).push.apply(_mainFileSet$filter, _toConsumableArray((0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(config.files)));
                delete config.files;
            }
        }
        return (0, (_deepAssign || _load_deepAssign()).deepAssign)(parentConfig, config);
    });

    return function getConfig(_x3, _x4, _x5, _x6) {
        return _ref2.apply(this, arguments);
    };
})();
/** @internal */


let getElectronVersion = exports.getElectronVersion = (() => {
    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (projectDir, config, projectMetadata) {
        if (config == null) {
            config = yield getConfig(projectDir, null, null, null);
        }
        if (config.electronVersion != null) {
            return config.electronVersion;
        }
        return yield computeElectronVersion(projectDir, projectMetadata);
    });

    return function getElectronVersion(_x7, _x8, _x9) {
        return _ref3.apply(this, arguments);
    };
})();
/** @internal */


let computeElectronVersion = exports.computeElectronVersion = (() => {
    var _ref4 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (projectDir, projectMetadata) {
        // projectMetadata passed only for prepacked app asar and in this case no dev deps in the app.asar
        if (projectMetadata == null) {
            for (const name of ["electron", "electron-prebuilt", "electron-prebuilt-compile"]) {
                try {
                    return (yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(projectDir, "node_modules", name, "package.json"))).version;
                } catch (e) {
                    if (e.code !== "ENOENT") {
                        (0, (_electronBuilderUtil || _load_electronBuilderUtil()).warn)(`Cannot read electron version from ${name} package.json: ${e.message}`);
                    }
                }
            }
        }
        const packageJsonPath = _path.join(projectDir, "package.json");
        const electronPrebuiltDep = findFromElectronPrebuilt(projectMetadata || (yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(packageJsonPath)));
        if (electronPrebuiltDep == null || electronPrebuiltDep === "latest") {
            try {
                const releaseInfo = yield (_nodeHttpExecutor || _load_nodeHttpExecutor()).httpExecutor.request({
                    hostname: "github.com",
                    path: "/electron/electron/releases/latest",
                    headers: {
                        Accept: "application/json"
                    }
                }, new (_electronBuilderHttp || _load_electronBuilderHttp()).CancellationToken());
                return releaseInfo.tag_name.startsWith("v") ? releaseInfo.tag_name.substring(1) : releaseInfo.tag_name;
            } catch (e) {
                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).warn)(e);
            }
            throw new Error(`Cannot find electron dependency to get electron version in the '${packageJsonPath}'`);
        }
        const firstChar = electronPrebuiltDep[0];
        return firstChar === "^" || firstChar === "~" ? electronPrebuiltDep.substring(1) : electronPrebuiltDep;
    });

    return function computeElectronVersion(_x10, _x11) {
        return _ref4.apply(this, arguments);
    };
})();

let createConfigValidator = (() => {
    var _ref5 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
        const ajv = new (_ajv || _load_ajv()).default({ allErrors: true, coerceTypes: true });
        ajv.addMetaSchema(require("ajv/lib/refs/json-schema-draft-04.json"));
        require("ajv-keywords")(ajv, ["typeof"]);
        const schema = yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(__dirname, "..", "..", "scheme.json"));
        return ajv.compile(schema);
    });

    return function createConfigValidator() {
        return _ref5.apply(this, arguments);
    };
})();
/** @internal */


let validateConfig = exports.validateConfig = (() => {
    var _ref6 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (config) {
        const extraMetadata = config.extraMetadata;
        if (extraMetadata != null) {
            if (extraMetadata.build != null) {
                throw new Error(`--em.build is deprecated, please specify as -c"`);
            }
            if (extraMetadata.directories != null) {
                throw new Error(`--em.directories is deprecated, please specify as -c.directories"`);
            }
        }
        // noinspection JSDeprecatedSymbols
        if (config.npmSkipBuildFromSource === false) {
            config.buildDependenciesFromSource = false;
        }
        if (validatorPromise == null) {
            validatorPromise = createConfigValidator();
        }
        const validator = yield validatorPromise;
        if (!validator(config)) {
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(JSON.stringify(validator.errors, null, 2));
            throw new Error(`Config is invalid:
${JSON.stringify(normaliseErrorMessages(validator.errors), null, 2)}

How to fix:
  1. Open https://github.com/electron-userland/electron-builder/wiki/Options
  2. Search the option name on the page.
    * Not found? The option was deprecated or not exists (check spelling).
    * Found? Check that the option in the appropriate place. e.g. "title" only in the "dmg", not in the root.
`);
        }
    });

    return function validateConfig(_x12) {
        return _ref6.apply(this, arguments);
    };
})();

/** @internal */
let computeDefaultAppDirectory = exports.computeDefaultAppDirectory = (() => {
    var _ref7 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (projectDir, userAppDir) {
        if (userAppDir != null) {
            const absolutePath = _path.resolve(projectDir, userAppDir);
            const stat = yield (0, (_fs || _load_fs()).statOrNull)(absolutePath);
            if (stat == null) {
                throw new Error(`Application directory ${userAppDir} doesn't exists`);
            } else if (!stat.isDirectory()) {
                throw new Error(`Application directory ${userAppDir} is not a directory`);
            } else if (projectDir === absolutePath) {
                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).warn)(`Specified application directory "${userAppDir}" equals to project dir — superfluous or wrong configuration`);
            }
            return absolutePath;
        }
        for (const dir of DEFAULT_APP_DIR_NAMES) {
            const absolutePath = _path.join(projectDir, dir);
            const packageJson = _path.join(absolutePath, "package.json");
            const stat = yield (0, (_fs || _load_fs()).statOrNull)(packageJson);
            if (stat != null && stat.isFile()) {
                return absolutePath;
            }
        }
        return projectDir;
    });

    return function computeDefaultAppDirectory(_x13, _x14) {
        return _ref7.apply(this, arguments);
    };
})();
//# sourceMappingURL=config.js.map


var _ajv;

function _load_ajv() {
    return _ajv = _interopRequireDefault(require("ajv"));
}

var _electronBuilderHttp;

function _load_electronBuilderHttp() {
    return _electronBuilderHttp = require("electron-builder-http");
}

var _electronBuilderUtil;

function _load_electronBuilderUtil() {
    return _electronBuilderUtil = require("electron-builder-util");
}

var _deepAssign;

function _load_deepAssign() {
    return _deepAssign = require("electron-builder-util/out/deepAssign");
}

var _fs;

function _load_fs() {
    return _fs = require("electron-builder-util/out/fs");
}

var _nodeHttpExecutor;

function _load_nodeHttpExecutor() {
    return _nodeHttpExecutor = require("electron-builder-util/out/nodeHttpExecutor");
}

var _promise;

function _load_promise() {
    return _promise = require("electron-builder-util/out/promise");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _readConfigFile;

function _load_readConfigFile() {
    return _readConfigFile = require("read-config-file");
}

var _rectCra;

function _load_rectCra() {
    return _rectCra = require("../presets/rectCra");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function getConfigFromPackageData(metadata) {
    return metadata == null ? null : metadata.build;
}

function findFromElectronPrebuilt(packageData) {
    for (const name of ["electron", "electron-prebuilt", "electron-prebuilt-compile"]) {
        const devDependencies = packageData.devDependencies;
        let dep = devDependencies == null ? null : devDependencies[name];
        if (dep == null) {
            const dependencies = packageData.dependencies;
            dep = dependencies == null ? null : dependencies[name];
        }
        if (dep != null) {
            return dep;
        }
    }
    return null;
}
let validatorPromise = null;

function normaliseErrorMessages(errors) {
    const result = Object.create(null);
    for (const e of errors) {
        if (e.keyword === "type" && e.params.type === "null") {
            // ignore - no sense to report that type accepts null
            continue;
        }
        const dataPath = e.dataPath.length === 0 ? [] : e.dataPath.substring(1).split(".");
        if (e.keyword === "additionalProperties") {
            dataPath.push(e.params.additionalProperty);
        }
        let o = result;
        let lastName = null;
        for (const p of dataPath) {
            if (p === dataPath[dataPath.length - 1]) {
                lastName = p;
                break;
            } else {
                if (o[p] == null) {
                    o[p] = Object.create(null);
                } else if (typeof o[p] === "string") {
                    o[p] = [o[p]];
                }
                o = o[p];
            }
        }
        if (lastName == null) {
            lastName = "unknown";
        }
        let message = e.message.toUpperCase()[0] + e.message.substring(1);
        switch (e.keyword) {
            case "additionalProperties":
                message = "Unknown option";
                break;
            case "required":
                message = "Required option";
                break;
            case "anyOf":
                message = "Invalid option object";
                break;
        }
        if (o[lastName] != null && !Array.isArray(o[lastName])) {
            o[lastName] = [o[lastName]];
        }
        if (Array.isArray(o[lastName])) {
            o[lastName].push(message);
        } else {
            o[lastName] = message;
        }
    }
    return result;
}
const DEFAULT_APP_DIR_NAMES = ["app", "www"];