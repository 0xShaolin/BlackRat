declare module "electron-builder/out/asar" {
  
  export function readAsar(archive: string): Promise<AsarFilesystem>

  export function readAsarJson(archive: string, file: string): Promise<any>
}

declare module "electron-builder/out/core" {
  import { Publish } from "electron-builder-http/out/publishOptions"
  export enum Arch {
    ia32 = 0,
    x64 = 1,
    armv7l = 2,
  }
  export type ArchType = "x64" | "ia32" | "armv7l"

  export function getArchSuffix(arch: Arch): string
  export type TargetConfigType = Array<string | TargetConfig> | string | TargetConfig | null

  export interface TargetConfig {
    /**
     * The target name. e.g. `snap`.
     */
    readonly target: string
    /**
     * The arch or list of archs.
     */
    readonly arch?: Array<"x64" | "ia32" | "armv7l"> | string
  }

  export function toLinuxArchString(arch: Arch): "armv7l" | "i386" | "amd64"

  export function archFromString(name: string): Arch

  export class Platform {
    name: string
    buildConfigurationKey: string
    nodeName: string
    static MAC: Platform
    static LINUX: Platform
    static WINDOWS: Platform
    static OSX: Platform
    constructor(name: string, buildConfigurationKey: string, nodeName: string)
    toString(): string
    createTarget(type?: string | Array<string> | null, ...archs: Array<Arch>): Map<Platform, Map<Arch, Array<string>>>
    static current(): Platform
    static fromString(name: string): Platform
  }

  export abstract class Target {
    readonly name: string
    readonly isAsyncSupported: boolean
    readonly abstract outDir: string
    readonly abstract options: TargetSpecificOptions | null | undefined
    constructor(name: string, isAsyncSupported?: boolean)
    abstract build(appOutDir: string, arch: Arch): Promise<any>
    finishBuild(): Promise<any>
  }

  export interface TargetSpecificOptions {
    /**
     The [artifact file name pattern](https://github.com/electron-userland/electron-builder/wiki/Options#artifact-file-name-pattern).
     */
    readonly artifactName?: string | null
    readonly publish?: Publish
  }
  export const DEFAULT_TARGET = "default"
  export const DIR_TARGET = "dir"
  export type CompressionLevel = "store" | "normal" | "maximum"

  export interface BeforeBuildContext {
    readonly appDir: string
    readonly electronVersion: string
    readonly platform: Platform
    readonly arch: string
  }

  export interface SourceRepositoryInfo {
    type?: string
    domain?: string
    user: string
    project: string
  }
}

declare module "electron-builder/out/util/flags" {
  
  export function isUseSystemWine(): boolean

  export function isUseSystemSigncode(): boolean

  export function isBuildCacheEnabled(): boolean

  export function isAutoDiscoveryCodeSignIdentity(): boolean
}

declare module "electron-builder/out/codeSign" {
  import { TmpDir } from "electron-builder-util"
  export const appleCertificatePrefixes: string[]
  export type CertType = "Developer ID Application" | "Developer ID Installer" | "3rd Party Mac Developer Application" | "3rd Party Mac Developer Installer" | "Mac Developer"

  export interface CodeSigningInfo {
    keychainName?: string | null
  }

  /** @private */
  export function downloadCertificate(urlOrBase64: string, tmpDir: TmpDir, currentDir: string): Promise<string>

  export interface CreateKeychainOptions {
    tmpDir: TmpDir
    cscLink: string
    cscKeyPassword: string
    cscILink?: string | null
    cscIKeyPassword?: string | null
    currentDir: string
  }

  export function createKeychain({tmpDir, cscLink, cscKeyPassword, cscILink, cscIKeyPassword, currentDir}: CreateKeychainOptions): Promise<CodeSigningInfo>

  /** @private */
  export function sign(path: string, name: string, keychain: string): Promise<any>
  export let findIdentityRawResult: Promise<Array<string>> | null

  export class Identity {
    readonly name: string
    readonly hash: string
    constructor(name: string, hash: string)
  }

  export function findIdentity(certType: CertType, qualifier?: string | null, keychain?: string | null): Promise<Identity | null>
}

declare module "electron-builder/out/options/linuxOptions" {
  import { TargetConfigType, TargetSpecificOptions } from "electron-builder/out/core"
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"

  export interface LinuxBuildOptions extends CommonLinuxOptions, PlatformSpecificBuildOptions {
    /**
     * The [package category](https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Section). Not applicable for AppImage.
     */
    readonly packageCategory?: string | null
    /**
     * Target package type: list of `AppImage`, `snap`, `deb`, `rpm`, `freebsd`, `pacman`, `p5p`, `apk`, `7z`, `zip`, `tar.xz`, `tar.lz`, `tar.gz`, `tar.bz2`, `dir`.
     *
     * electron-builder [docker image](https://github.com/electron-userland/electron-builder/wiki/Docker) can be used to build Linux targets on any platform. See [Multi platform build](https://github.com/electron-userland/electron-builder/wiki/Multi-Platform-Build).
     *
     * @see [Please do not put an AppImage into another archive like a .zip or .tar.gz](https://github.com/probonopd/AppImageKit/wiki/Creating-AppImages#common-mistake)
     * @default AppImage
     */
    readonly target?: TargetConfigType
    /**
     * The maintainer. Defaults to [author](#Metadata-author).
     */
    readonly maintainer?: string | null
    /**
     * The vendor. Defaults to [author](#Metadata-author).
     */
    readonly vendor?: string | null
    /**
     * @deprecated
     * @private
     */
    readonly depends?: Array<string> | null
    /**
     * The executable name. Defaults to `productName`.
     * Cannot be specified per target, allowed only in the `linux`.
     */
    readonly executableName?: string | null
    /**
     * The path to icon set directory, relative to the the [build resources](https://github.com/electron-userland/electron-builder/wiki/Options#MetadataDirectories-buildResources) or to the project directory. The icon filename must contain the size (e.g. 32x32.png) of the icon.
     * By default will be generated automatically based on the macOS icns file.
     */
    readonly icon?: string
  }

  export interface CommonLinuxOptions {
    /**
     * The [short description](https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Description).
     */
    readonly synopsis?: string | null
    /**
     * As [description](#Metadata-description) from application package.json, but allows you to specify different for Linux.
     */
    readonly description?: string | null
    /**
     * The [application category](https://specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry).
     */
    readonly category?: string | null
    readonly packageCategory?: string | null
    /**
     * The [Desktop file](https://developer.gnome.org/integration-guide/stable/desktop-files.html.en) entries (name to value).
     */
    readonly desktop?: any | null
    readonly vendor?: string | null
    readonly maintainer?: string | null
    readonly afterInstall?: string | null
    readonly afterRemove?: string | null
    /**
     * should be not documented, only to experiment
     * @private
     */
    readonly fpm?: Array<string> | null
  }

  export interface LinuxTargetSpecificOptions extends CommonLinuxOptions, TargetSpecificOptions {
    /**
     * Package dependencies.
     */
    readonly depends?: Array<string> | null
    readonly icon?: string
  }

  export interface DebOptions extends LinuxTargetSpecificOptions {
    /**
     * The compression type.
     * @default xz
     */
    readonly compression?: "gz" | "bzip2" | "xz" | null
    /**
     * The [Priority](https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Priority) attribute.
     */
    readonly priority?: string | null
    /**
     * Package dependencies. Defaults to `["gconf2", "gconf-service", "libnotify4", "libappindicator1", "libxtst6", "libnss3"]`.
     */
    readonly depends?: Array<string> | null
  }

  export interface SnapOptions extends LinuxBuildOptions {
    /**
     * The type of [confinement](https://snapcraft.io/docs/reference/confinement) supported by the snap.
     * @default strict
     */
    readonly confinement?: "devmode" | "strict" | "classic" | null
    /**
     * The 78 character long summary. Defaults to [productName](#Config-productName).
     */
    readonly summary?: string | null
    /**
     * The quality grade of the snap. It can be either `devel` (i.e. a development version of the snap, so not to be published to the “stable” or “candidate” channels) or “stable” (i.e. a stable release or release candidate, which can be released to all channels).
     * @default stable
     */
    readonly grade?: "devel" | "stable" | null
    /**
     * The list of features that must be supported by the core in order for this snap to install.
     */
    readonly assumes?: Array<string> | null
    /**
     * The list of debian packages needs to be installed for building this snap.
     */
    readonly buildPackages?: Array<string> | null
    /**
     * The list of Ubuntu packages to use that are needed to support the `app` part creation. Like `depends` for `deb`.
     * Defaults to `["libnotify4", "libappindicator1", "libxtst6", "libnss3", "libxss1", "fontconfig-config", "gconf2", "libasound2", "pulseaudio"]`.
     *
     * If list contains `default`, it will be replaced to default list, so, `["default", "foo"]` can be used to add custom package `foo` in addition to defaults.
     */
    readonly stagePackages?: Array<string> | null
    /**
     * The list of [plugs](https://snapcraft.io/docs/reference/interfaces).
     * Defaults to `["home", "x11", "unity7", "browser-support", "network", "gsettings", "pulseaudio", "opengl"]`.
     *
     * If list contains `default`, it will be replaced to default list, so, `["default", "foo"]` can be used to add custom plug `foo` in addition to defaults.
     */
    readonly plugs?: Array<string> | null
    /**
     * Specifies any [parts](https://snapcraft.io/docs/reference/parts) that should be built before this part.
     * Defaults to `["desktop-only""]`.
     *
     * If list contains `default`, it will be replaced to default list, so, `["default", "foo"]` can be used to add custom parts `foo` in addition to defaults.
     */
    readonly after?: Array<string> | null
    /**
     * Specify `ubuntu-app-platform1` to use [ubuntu-app-platform](https://insights.ubuntu.com/2016/11/17/how-to-create-snap-packages-on-qt-applications/).
     * Snap size will be greatly reduced, but it is not recommended for now because "the snaps must be connected before running uitk-gallery for the first time".
     */
    readonly ubuntuAppPlatformContent?: string | null
  }
}

declare module "electron-builder/out/options/winOptions" {
  import { TargetConfigType, TargetSpecificOptions } from "electron-builder/out/core"
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"

  export interface WinBuildOptions extends PlatformSpecificBuildOptions {
    /**
     * Target package type: list of `nsis`, `nsis-web` (Web installer), `portable` (portable app without installation), `appx`, `squirrel`, `7z`, `zip`, `tar.xz`, `tar.lz`, `tar.gz`, `tar.bz2`, `dir`.
     * AppX package can be built only on Windows 10.
     *
     * To use Squirrel.Windows please install `electron-builder-squirrel-windows` dependency.
     *
     * For `portable` app, `PORTABLE_EXECUTABLE_DIR` env is set (dir where portable executable located).
     *
     * @default nsis
    */
    readonly target?: TargetConfigType
    /**
     * Array of signing algorithms used. For AppX `sha256` is always used.
     * @default ['sha1', 'sha256']
     */
    readonly signingHashAlgorithms?: Array<"sha1" | "sha256"> | null
    /**
     * The path to application icon.
     * @default build/icon.ico
     */
    readonly icon?: string | null
    /**
     * The trademarks and registered trademarks.
     */
    readonly legalTrademarks?: string | null
    /**
     * The path to the *.pfx certificate you want to sign with. Please use it only if you cannot use env variable `CSC_LINK` (`WIN_CSC_LINK`) for some reason.
     * Please see [Code Signing](https://github.com/electron-userland/electron-builder/wiki/Code-Signing).
     */
    readonly certificateFile?: string | null
    /**
     * The password to the certificate provided in `certificateFile`. Please use it only if you cannot use env variable `CSC_KEY_PASSWORD` (`WIN_CSC_KEY_PASSWORD`) for some reason.
     * Please see [Code Signing](https://github.com/electron-userland/electron-builder/wiki/Code-Signing).
     */
    readonly certificatePassword?: string | null
    /**
     * The name of the subject of the signing certificate. Required only for EV Code Signing and works only on Windows.
     */
    readonly certificateSubjectName?: string | null
    /**
     * The SHA1 hash of the signing certificate. The SHA1 hash is commonly specified when multiple certificates satisfy the criteria specified by the remaining switches. Works only on Windows.
     */
    readonly certificateSha1?: string | null
    /**
     * The path to an additional certificate file you want to add to the signature block.
     */
    readonly additionalCertificateFile?: string | null
    /**
     * The URL of the RFC 3161 time stamp server.
     * @default http://timestamp.comodoca.com/rfc3161
     */
    readonly rfc3161TimeStampServer?: string | null
    /**
     * The URL of the time stamp server.
     * @default http://timestamp.verisign.com/scripts/timstamp.dll
     */
    readonly timeStampServer?: string | null
    /**
     * [The publisher name](https://github.com/electron-userland/electron-builder/issues/1187#issuecomment-278972073), exactly as in your code signed certificate. Several names can be provided.
     * Defaults to common name from your code signing certificate.
     */
    readonly publisherName?: string | Array<string> | null
    /**
     * Whether to verify the signature of an available update before installation.
     * The [publisher name](WinBuildOptions#publisherName) will be used for the signature verification.
     *
     * @default true
     */
    readonly verifyUpdateCodeSignature?: boolean
  }

  export interface CommonNsisOptions {
    /**
     * Whether to create [Unicode installer](http://nsis.sourceforge.net/Docs/Chapter1.html#intro-unicode).
     * @default true
     */
    readonly unicode?: boolean
    /**
     * See [GUID vs Application Name](https://github.com/electron-userland/electron-builder/wiki/NSIS#guid-vs-application-name).
     */
    readonly guid?: string | null
    /**
     * If `warningsAsErrors` is `true` (default): NSIS will treat warnings as errors. If `warningsAsErrors` is `false`: NSIS will allow warnings.
     * @default true
     */
    readonly warningsAsErrors?: boolean
    /**
     * @private
     * @default false
     */
    readonly useZip?: boolean
  }

  /**
   * NSIS options. See [NSIS target notes](https://github.com/electron-userland/electron-builder/wiki/NSIS).
   */
  export interface NsisOptions extends CommonNsisOptions, TargetSpecificOptions {
    /**
     * One-click installation.
     * @default true
     */
    readonly oneClick?: boolean
    /***
     * If `oneClick` is `true` (default): Install per all users (per-machine).
     *
     * If `oneClick` is `false`: no install mode installer page (choice per-machine or per-user), always install per-machine.
     * @default false
     */
    readonly perMachine?: boolean
    /**
     * *boring installer only.* Allow requesting for elevation. If false, user will have to restart installer with elevated permissions.
     * @default true
     */
    readonly allowElevation?: boolean
    /**
     * *boring installer only.* Whether to allow user to change installation directory.
     * @default false
     */
    readonly allowToChangeInstallationDirectory?: boolean
    /**
     * Whether to create desktop shortcut.
     * @default true
     */
    readonly createDesktopShortcut?: boolean
    /**
     * *one-click installer only.* Run application after finish.
     * @default true
     */
    readonly runAfterFinish?: boolean
    /**
     * The path to installer icon, relative to the the [build resources](https://github.com/electron-userland/electron-builder/wiki/Options#MetadataDirectories-buildResources) or to the project directory.
     * Defaults to `build/installerIcon.ico` or application icon.
     */
    readonly installerIcon?: string | null
    /**
     * The path to uninstaller icon, relative to the the [build resources](https://github.com/electron-userland/electron-builder/wiki/Options#MetadataDirectories-buildResources) or to the project directory.
     * Defaults to `build/uninstallerIcon.ico` or application icon.
     */
    readonly uninstallerIcon?: string | null
    /**
     * *boring installer only.* `MUI_HEADERIMAGE`, relative to the the [build resources](https://github.com/electron-userland/electron-builder/wiki/Options#MetadataDirectories-buildResources) or to the project directory.
     * @default build/installerHeader.bmp
     */
    readonly installerHeader?: string | null
    /**
     * *boring installer only.* `MUI_WELCOMEFINISHPAGE_BITMAP`, relative to the the [build resources](https://github.com/electron-userland/electron-builder/wiki/Options#MetadataDirectories-buildResources) or to the project directory.
     * Defaults to `build/installerSidebar.bmp` or `${NSISDIR}\\Contrib\\Graphics\\Wizard\\nsis3-metro.bmp`
     */
    readonly installerSidebar?: string | null
    /**
     * *boring installer only.* `MUI_UNWELCOMEFINISHPAGE_BITMAP`, relative to the the [build resources](https://github.com/electron-userland/electron-builder/wiki/Options#MetadataDirectories-buildResources) or to the project directory.
     * Defaults to `installerSidebar` option or `build/uninstallerSidebar.bmp` or `build/installerSidebar.bmp` or `${NSISDIR}\\Contrib\\Graphics\\Wizard\\nsis3-metro.bmp`
     */
    readonly uninstallerSidebar?: string | null
    /**
     * *one-click installer only.* The path to header icon (above the progress bar), relative to the the [build resources](https://github.com/electron-userland/electron-builder/wiki/Options#MetadataDirectories-buildResources) or to the project directory.
     * Defaults to `build/installerHeaderIcon.ico` or application icon.
     */
    readonly installerHeaderIcon?: string | null
    /**
     * The path to NSIS include script to customize installer. Defaults to `build/installer.nsh`. See [Custom NSIS script](https://github.com/electron-userland/electron-builder/wiki/NSIS#custom-nsis-script).
     */
    readonly include?: string | null
    /**
     * The path to NSIS script to customize installer. Defaults to `build/installer.nsi`. See [Custom NSIS script](https://github.com/electron-userland/electron-builder/wiki/NSIS#custom-nsis-script).
     */
    readonly script?: string | null
    /**
     * The path to EULA license file. Defaults to `license.rtf` or `license.txt` or `eula.rtf` or `eula.txt` (or uppercase variants, e.g. `EULA.txt` or `LICENSE.TXT`).
     *
     * Multiple license files in different languages are supported — use lang postfix (e.g. `_de`, `_ru`)). For example, create files `license_de.txt` and `license_en.txt` in the build resources.
     * If OS language is german, `license_de.txt` will be displayed. See map of [language code to name](https://github.com/meikidd/iso-639-1/blob/master/src/data.js).
     *
     * Appropriate license file will be selected by user OS language.
     */
    readonly license?: string | null
    /**
     * [LCID Dec](https://msdn.microsoft.com/en-au/goglobal/bb964664.aspx), defaults to `1033`(`English - United States`).
     */
    readonly language?: string | null
    /**
     * *boring installer only.* Whether to create multi-language installer. Defaults to `unicode` option value.
     * [Not all strings are translated](https://github.com/electron-userland/electron-builder/issues/646#issuecomment-238155800).
     */
    readonly multiLanguageInstaller?: boolean
    /**
     * Whether to create submenu for start menu shortcut and program files directory. If `true`, company name will be used. Or string value.
     * @default false
     */
    readonly menuCategory?: boolean | string
    /**
     * The uninstaller display name in the control panel.
     * @default ${productName} ${version}
     */
    readonly uninstallDisplayName?: string
    /**
     * The [artifact file name pattern](https://github.com/electron-userland/electron-builder/wiki/Options#artifact-file-name-pattern). Defaults to `${productName} Setup ${version}.${ext}`.
     */
    readonly artifactName?: string | null
    /**
     * *one-click installer only.* Whether to delete app data on uninstall.
     * @default false
     */
    readonly deleteAppDataOnUninstall?: boolean
    /**
     * Whether to pack the elevate executable (required for electron-updater if per-machine installer used or can be used in the future). Ignored if `perMachine` is set to `true`.
     * @default true
     */
    readonly packElevateHelper?: boolean
    /**
     * @private
     * @default false
     */
    readonly differentialPackage?: boolean
  }

  /**
   * Portable specific options.
   */
  export interface PortableOptions extends TargetSpecificOptions, CommonNsisOptions {
    /**
     * The [requested execution level](http://nsis.sourceforge.net/Reference/RequestExecutionLevel) for Windows.
     * @default user
     */
    readonly requestExecutionLevel?: "user" | "highest" | "admin"
  }

  /**
   * Web Installer specific options.
   */
  export interface NsisWebOptions extends NsisOptions {
    /**
     * The application package download URL. Optional — by default computed using publish configuration.
     *
     * URL like `https://example.com/download/latest` allows web installer to be version independent (installer will download latest application package).
     *
     * Custom `X-Arch` http header is set to `32` or `64`.
     */
    readonly appPackageUrl?: string | null
    /**
     * The [artifact file name pattern](https://github.com/electron-userland/electron-builder/wiki/Options#artifact-file-name-pattern). Defaults to `${productName} Web Setup ${version}.${ext}`.
     */
    readonly artifactName?: string | null
  }

  /**
   * Squirrel.Windows options. Squirrel.Windows target is maintained, but deprecated. Please use `nsis` instead.
   *
   * To use Squirrel.Windows please install `electron-builder-squirrel-windows` dependency.
   * To build for Squirrel.Windows on macOS, please install `mono`: `brew install mono`.
   */
  export interface SquirrelWindowsOptions extends WinBuildOptions {
    /**
     * A URL to an ICO file to use as the application icon (displayed in Control Panel > Programs and Features). Defaults to the Electron icon.
     *
     * Please note — [local icon file url is not accepted](https://github.com/atom/grunt-electron-installer/issues/73), must be https/http.
     *
     * If you don't plan to build windows installer, you can omit it.
     * If your project repository is public on GitHub, it will be `https://github.com/${u}/${p}/blob/master/build/icon.ico?raw=true` by default.
     */
    readonly iconUrl?: string | null
    /**
     * The path to a .gif file to display during install. `build/install-spinner.gif` will be used if exists (it is a recommended way to set)
     * (otherwise [default](https://github.com/electron/windows-installer/blob/master/resources/install-spinner.gif)).
     */
    readonly loadingGif?: string | null
    /**
     * Whether to create an MSI installer. Defaults to `false` (MSI is not created).
     */
    readonly msi?: boolean
    /**
     * A URL to your existing updates. Or `true` to automatically set to your GitHub repository. If given, these will be downloaded to create delta updates.
     */
    readonly remoteReleases?: string | boolean | null
    /**
     * Authentication token for remote updates
     */
    readonly remoteToken?: string | null
    /**
     * Use `appId` to identify package instead of `name`.
     */
    readonly useAppIdAsId?: boolean
    /**
     * https://github.com/electron-userland/electron-builder/issues/1743
     * @private
     */
    readonly name?: string
  }

  /**
   * AppX options. See [Windows AppX docs](https://msdn.microsoft.com/en-us/library/windows/apps/br211453.aspx).
   */
  export interface AppXOptions extends TargetSpecificOptions {
    /**
     * The background color of the app tile.
     * @see [Visual Elements](https://msdn.microsoft.com/en-us/library/windows/apps/br211471.aspx).
     */
    readonly backgroundColor?: string | null
    /**
     * @private
     */
    readonly makeappxArgs?: Array<string> | null
    /**
     * Describes the publisher information in a form `CN=your name exactly as in your cert`. The Publisher attribute must match the publisher subject information of the certificate used to sign a package.
     * By default will be extracted from code sign certificate.
     */
    readonly publisher?: string | null
    /**
     * A friendly name that can be displayed to users. Corresponds to [Properties.DisplayName](https://msdn.microsoft.com/en-us/library/windows/apps/br211432.aspx).
     */
    readonly displayName?: string | null
    /**
     * A friendly name for the publisher that can be displayed to users. Corresponds to [Properties.PublisherDisplayName](https://msdn.microsoft.com/en-us/library/windows/apps/br211460.aspx).
     */
    readonly publisherDisplayName?: string | null
    /**
     * The name. Corresponds to [Identity.Name](https://msdn.microsoft.com/en-us/library/windows/apps/br211441.aspx).
     * @default ${name}
     */
    readonly identityName?: string | null
    /**
     * The list of [supported languages](https://docs.microsoft.com/en-us/windows/uwp/globalizing/manage-language-and-region#specify-the-supported-languages-in-the-apps-manifest) that will be listed in the Windows Store.
     * The first entry (index 0) will be the default language.
     * Defaults to en-US if omitted.
     */
    readonly languages?: Array<string> | string | null
  }
}

declare module "electron-builder/out/packagerApi" {
  /// <reference types="node" />
  import { PublishConfiguration } from "electron-builder-http/out/publishOptions"
  import { Arch, Platform, Target } from "electron-builder/out/core"
  import { Config } from "electron-builder/out/metadata"
  import { Packager } from "electron-builder/out/packager"
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  export interface PackagerOptions {
    targets?: Map<Platform, Map<Arch, Array<string>>>
    projectDir?: string | null
    cscLink?: string | null
    cscKeyPassword?: string | null
    cscInstallerLink?: string | null
    cscInstallerKeyPassword?: string | null
    platformPackagerFactory?: ((info: Packager, platform: Platform) => PlatformPackager<any>) | null
    readonly config?: Config | string | null
    readonly effectiveOptionComputed?: (options: any) => Promise<boolean>
    readonly prepackaged?: string | null
  }

  export interface ArtifactCreated {
    readonly packager: PlatformPackager<any>
    readonly target: Target | null
    readonly arch: Arch | null
    readonly file?: string
    readonly data?: Buffer
    readonly safeArtifactName?: string
    readonly publishConfig?: PublishConfiguration
  }
}

declare module "electron-builder/out/util/packageDependencies" {
  import { Lazy } from "electron-builder-util"

  export function createLazyProductionDeps(projectDir: string): Lazy<Dependency[]>
}

declare module "electron-builder/out/util/AppFileCopierHelper" {
  /// <reference types="node" />
  import { FileTransformer } from "electron-builder-util/out/fs"
  import { Stats } from "fs-extra-p"
  import { FileMatcher } from "electron-builder/out/fileMatcher"
  import { Packager } from "electron-builder/out/packager"

  export interface FileSet {
    src: string
    destination: string
    files: Array<string>
    metadata: Map<string, Stats>
    transformedFiles: Array<string | Buffer | true | null>
  }

  export function computeFileSets(matchers: Array<FileMatcher>, transformer: FileTransformer, packager: Packager, isElectronCompile: boolean): Promise<Array<FileSet>>
}

declare module "electron-builder/out/util/asyncTaskManager" {
  import { CancellationToken } from "electron-builder-http"

  /** @private */
  export class AsyncTaskManager {
    private readonly cancellationToken
    readonly tasks: Array<Promise<any>>
    private readonly errors
    constructor(cancellationToken: CancellationToken)
    add(task: () => Promise<any>): void
    addTask(promise: Promise<any>): void
    cancelTasks(): void
    awaitTasks(): Promise<Array<any>>
  }
}

declare module "electron-builder/out/util/asarUtil" {
  /// <reference types="node" />
  import { FileCopier } from "electron-builder-util/out/fs"
  import { Stats } from "fs-extra-p"

  export function copyFileOrData(fileCopier: FileCopier, data: string | Buffer | undefined | null, src: string, destination: string, stats: Stats): Promise<void>
}

declare module "electron-builder/out/util/appFileCopier" {
  import { Packager } from "electron-builder/out/packager"
  import { FileSet } from "electron-builder/out/util/AppFileCopierHelper"

  export function copyAppFiles(fileSet: FileSet, packager: Packager): Promise<void>
}

declare module "electron-builder/out/platformPackager" {
  import { AppInfo } from "electron-builder/out/appInfo"
  import { Arch, Platform, Target, TargetSpecificOptions } from "electron-builder/out/core"
  import { AfterPackContext, Config, FileAssociation, PlatformSpecificBuildOptions } from "electron-builder/out/metadata"
  import { Packager } from "electron-builder/out/packager"
  import { PackagerOptions } from "electron-builder/out/packagerApi"
  import { AsyncTaskManager } from "electron-builder/out/util/asyncTaskManager"

  export abstract class PlatformPackager<DC extends PlatformSpecificBuildOptions> {
    readonly info: Packager
    readonly packagerOptions: PackagerOptions
    readonly projectDir: string
    readonly buildResourcesDir: string
    readonly config: Config
    readonly platformSpecificBuildOptions: DC
    readonly resourceList: Promise<Array<string>>
    private readonly _resourceList
    readonly abstract platform: Platform
    readonly appInfo: AppInfo
    constructor(info: Packager)
    readonly abstract defaultTarget: Array<string>
    protected prepareAppInfo(appInfo: AppInfo): AppInfo
    private static normalizePlatformSpecificBuildOptions(options)
    abstract createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void): void
    protected getCscPassword(): string
    protected doGetCscPassword(): string | undefined
    readonly relativeBuildResourcesDirname: string
    protected computeAppOutDir(outDir: string, arch: Arch): string
    dispatchArtifactCreated(file: string, target: Target | null, arch: Arch | null, safeArtifactName?: string): void
    pack(outDir: string, arch: Arch, targets: Array<Target>, taskManager: AsyncTaskManager): Promise<any>
    protected packageInDistributableFormat(appOutDir: string, arch: Arch, targets: Array<Target>, taskManager: AsyncTaskManager): void
    private getExtraFileMatchers(isResources, appOutDir, macroExpander, customBuildOptions)
    readonly electronDistMacOsAppName: string
    readonly electronDistExecutableName: string
    readonly electronDistMacOsExecutableName: string
    protected doPack(outDir: string, appOutDir: string, platformName: string, arch: Arch, platformSpecificBuildOptions: DC, targets: Array<Target>): Promise<void>
    private copyAppFiles(taskManager, asarOptions, resourcePath, outDir, platformSpecificBuildOptions, excludePatterns, macroExpander)
    protected postInitApp(packContext: AfterPackContext): Promise<any>
    protected signApp(packContext: AfterPackContext): Promise<any>
    getIconPath(): Promise<string | null>
    private computeAsarOptions(customBuildOptions)
    getElectronSrcDir(dist: string): string
    getElectronDestinationDir(appOutDir: string): string
    getResourcesDir(appOutDir: string): string
    getMacOsResourcesDir(appOutDir: string): string
    private checkFileInPackage(resourcesDir, file, messagePrefix, isAsar)
    private sanityCheckPackage(appOutDir, isAsar)
    computeSafeArtifactName(ext: string, arch?: Arch | null, skipArchIfX64?: boolean): string
    expandArtifactNamePattern(targetSpecificOptions: TargetSpecificOptions | n, ext: string, arch?: Arch | null, defaultPattern?: string, skipArchIfX64?: boolean): string
    private computeArtifactName(pattern, ext, arch)
    expandMacro(pattern: string, arch?: string | null, extra?: any, isProductNameSanitized?: boolean): string
    generateName(ext: string | null, arch: Arch, deployment: boolean, classifier?: string | null): string
    generateName2(ext: string | null, classifier: string | n, deployment: boolean): string
    getDefaultIcon(ext: string): Promise<string | null>
    getTempFile(suffix: string): Promise<string>
    readonly fileAssociations: Array<FileAssociation>
    getResource(custom: string | n, ...names: Array<string>): Promise<string | null>
    readonly forceCodeSigning: boolean
  }

  export function normalizeExt(ext: string): string
}

declare module "electron-builder/out/metadata" {
  import { AsarIntegrityOptions } from "asar-integrity"
  import { Publish } from "electron-builder-http/out/publishOptions"
  import { Arch, BeforeBuildContext, CompressionLevel, Target, TargetConfig, TargetSpecificOptions } from "electron-builder/out/core"
  import { DebOptions, LinuxBuildOptions, LinuxTargetSpecificOptions, SnapOptions } from "electron-builder/out/options/linuxOptions"
  import { DmgOptions, MacOptions, MasBuildOptions, PkgOptions } from "electron-builder/out/options/macOptions"
  import { AppXOptions, NsisOptions, NsisWebOptions, PortableOptions, SquirrelWindowsOptions, WinBuildOptions } from "electron-builder/out/options/winOptions"
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  /**
   * Some standard fields should be defined in the `package.json`.
   */
  export interface Metadata {
    /**
     * The application name.
     * @required
     */
    readonly name?: string
    /**
     * The application description.
     */
    readonly description?: string
    /**
     * The url to the project [homepage](https://docs.npmjs.com/files/package.json#homepage) (NuGet Package `projectUrl` (optional) or Linux Package URL (required)).
     *
     * If not specified and your project repository is public on GitHub, it will be `https://github.com/${user}/${project}` by default.
     */
    readonly homepage?: string | null
    /**
     * *linux-only.* The [license](https://docs.npmjs.com/files/package.json#license) name.
     */
    readonly license?: string | null
    readonly author?: AuthorMetadata
    /**
     * The [repository](https://docs.npmjs.com/files/package.json#repository).
     */
    readonly repository?: string | RepositoryInfo | null
    /**
     * The electron-builder configuration.
     */
    readonly build?: Config
    /** @private */
    readonly dependencies?: {
      [key: string]: string
    }
    /** @private */
    readonly version?: string
    /** @private */
    readonly productName?: string | null
    /** @private */
    readonly main?: string | null
  }

  export interface AuthorMetadata {
    readonly name: string
    readonly email?: string
  }

  export interface RepositoryInfo {
    readonly url: string
  }

  /**
   * Configuration Options
   */
  export interface Config extends PlatformSpecificBuildOptions {
    /**
     * The application id. Used as [CFBundleIdentifier](https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-102070) for MacOS and as
     * [Application User Model ID](https://msdn.microsoft.com/en-us/library/windows/desktop/dd378459(v=vs.85).aspx) for Windows (NSIS target only, Squirrel.Windows not supported). It is strongly recommended that an explicit ID be set.
     * @default com.electron.${name}
     */
    readonly appId?: string | null
    /**
     * As [name](#Metadata-name), but allows you to specify a product name for your executable which contains spaces and other special characters not allowed in the [name property](https://docs.npmjs.com/files/package.json#name}).
     */
    readonly productName?: string | null
    /**
     * The [artifact file name pattern](https://github.com/electron-userland/electron-builder/wiki/Options#artifact-file-name-pattern). Defaults to `${productName}-${version}.${ext}` (some target can have another defaults, see corresponding options).
     */
    readonly artifactName?: string | null
    /**
     * Whether to package the application's source code into an archive, using [Electron's archive format](http://electron.atom.io/docs/tutorial/application-packaging/).
     *
     * Node modules, that must be unpacked, will be detected automatically, you don't need to explicitly set [asarUnpack](#Config-asarUnpack) - please file issue if this doesn't work.
     * @default true
    */
    readonly asar?: boolean | AsarOptions | null
    /**
     * A [glob patterns](#file-patterns) relative to the [app directory](#MetadataDirectories-app), which specifies which files to unpack when creating the [asar](http://electron.atom.io/docs/tutorial/application-packaging/) archive.
     */
    readonly asarUnpack?: Array<string> | string | null
    /**
     * The compression level. If you want to rapidly test build, `store` can reduce build time significantly.
     * @default normal
     */
    readonly compression?: CompressionLevel | null
    /**
     * The human-readable copyright line for the app.
     * @default Copyright © year ${author}
     */
    readonly copyright?: string | null
    readonly directories?: MetadataDirectories | null
    /**
     * A [glob patterns](#file-patterns) relative to the [app directory](#MetadataDirectories-app), which specifies which files to include when copying files to create the package.
     *
     * Development dependencies are never copied in any case. You don't need to ignore it explicitly.
     *
     * Default pattern `**\/*` **is not added to your custom** if some of your patterns is not ignore (i.e. not starts with `!`).
     * `package.json` and `**\/node_modules/**\/*` (only production dependencies will be copied) is added to your custom in any case.
     * All [default ignores](#default-file-pattern) are added in any case — you don't need to repeat it if you configure own patterns.
     *
     * May be specified in the platform options (e.g. in the [mac](#MacOptions)).
     *
     * You may also specify custom source and destination directories by using JSON objects instead of simple glob patterns.
     *
     *```json<br>
     * [<br>
     *   {<br>
     *   "from": "path/to/source",<br>
     *   "to": "path/to/destination",<br>
     *   "filter": ["**\/*", "!foo/*.js"]<br>
     *   }<br>
     * ]<br>
     * ```
     *
     * You can use [file macros](#file-macros) in the `from` and `to` fields as well. `from` and `to` can be files and you can use this to [rename](https://github.com/electron-userland/electron-builder/issues/1119) a file while packaging.
     */
    readonly files?: Array<FilePattern | string> | FilePattern | string | null
    /**
     * A [glob patterns](#file-patterns) relative to the project directory, when specified, copy the file or directory with matching names directly into the app's resources directory (`Contents/Resources` for MacOS, `resources` for Linux/Windows).
     *
     * File patterns (and support for `from` and `to` fields) the same as for [files](#multiple-glob-patterns).
     */
    readonly extraResources?: Array<FilePattern | string> | FilePattern | string | null
    /**
     * The same as [extraResources](#Config-extraResources) but copy into the app's content directory (`Contents` for MacOS, root directory for Linux/Windows).
     */
    readonly extraFiles?: Array<FilePattern | string> | FilePattern | string | null
    /**
     * The file associations.
     */
    readonly fileAssociations?: Array<FileAssociation> | FileAssociation
    /**
     * The URL protocol schemes.
     */
    readonly protocols?: Array<Protocol> | Protocol
    /**
     * Whether to use [electron-compile](http://github.com/electron/electron-compile) to compile app. Defaults to `true` if `electron-compile` in the dependencies. And `false` if in the `devDependencies` or doesn't specified.
     */
    readonly electronCompile?: boolean
    /**
     * The path to custom Electron build (e.g. `~/electron/out/R`).
     */
    readonly electronDist?: string
    /**
     * The [electron-download](https://github.com/electron-userland/electron-download#usage) options.
     */
    readonly electronDownload?: ElectronDownloadOptions
    /**
     * The version of electron you are packaging for. Defaults to version of `electron`, `electron-prebuilt` or `electron-prebuilt-compile` dependency.
     */
    electronVersion?: string | null
    /**
     * The name of a built-in configuration preset or path to config file (relative to project dir). Currently, only `react-cra` is supported.
     *
     * If `react-scripts` in the app dev dependencies, `react-cra` will be set automatically. Set to `null` to disable automatic detection.
     */
    extends?: string | null
    /**
     * Inject properties to `package.json`.
     */
    readonly extraMetadata?: any
    /**
     * Whether to fail if application will be not signed (to prevent unsigned app if code signing configuration is not correct).
     * @default false
     */
    readonly forceCodeSigning?: boolean
    /**
     * The version of muon you are packaging for.
     */
    readonly muonVersion?: string | null
    /**
     * Whether to execute `node-gyp rebuild` before starting to package the app.
     * @default false
     */
    readonly nodeGypRebuild?: boolean
    /**
     * Additional command line arguments to use when installing app native deps.
     */
    readonly npmArgs?: Array<string> | string | null
    /**
     * Whether to [rebuild](https://docs.npmjs.com/cli/rebuild) native dependencies (`npm rebuild`) before starting to package the app.
     * @default true
     */
    readonly npmRebuild?: boolean
    /**
     * Whether to build the application native dependencies from source.
     * @default false
     */
    buildDependenciesFromSource?: boolean
    /**
     * @deprecated Please use npmBuildFromSource.
     */
    readonly npmSkipBuildFromSource?: boolean
    /**
     * The [publish configuration](https://github.com/electron-userland/electron-builder/wiki/Publishing-Artifacts#publish-options). Order is important — first item will be used as a default auto-update server.
     *
     * If `GH_TOKEN` is set — defaults to `[{provider: "github"}]`.
     *
     * If `BT_TOKEN` is set and `GH_TOKEN` is not set — defaults to `[{provider: "bintray"}]`.
     */
    readonly publish?: Publish
    /**
     * The release info. Intended for command line usage (`-c.releaseInfo.releaseNotes="new features"`) or programmatically.
     */
    readonly releaseInfo?: ReleaseInfo
    /**
     * The build version. Maps to the `CFBundleVersion` on macOS, and `FileVersion` metadata property on Windows. Defaults to the `version`.
     * If `TRAVIS_BUILD_NUMBER` or `APPVEYOR_BUILD_NUMBER` or `CIRCLE_BUILD_NUM` or `BUILD_NUMBER` or `bamboo.buildNumber` env defined, it will be used as a build version (`version.build_number`).
     */
    readonly buildVersion?: string | null
    /**
     * Whether to infer update channel from application version prerelease components. e.g. if version `0.12.1-alpha.1`, channel will be set to `alpha`. Otherwise to `latest`.
     * @default true
     */
    readonly detectUpdateChannel?: boolean
    /**
     * macOS options.
     */
    readonly mac?: MacOptions | null
    /**
     * MAS (Mac Application Store) options.
     */
    readonly mas?: MasBuildOptions | null
    /**
     * macOS DMG options.
     *
     * To add license to DMG, create file `license_LANG_CODE.txt` in the build resources. Multiple license files in different languages are supported — use lang postfix (e.g. `_de`, `_ru`)). For example, create files `license_de.txt` and `license_en.txt` in the build resources.
     * If OS language is german, `license_de.txt` will be displayed. See map of [language code to name](https://github.com/meikidd/iso-639-1/blob/master/src/data.js).
     */
    readonly dmg?: DmgOptions | null
    readonly pkg?: PkgOptions | null
    /**
     * Windows options.
     */
    readonly win?: WinBuildOptions | null
    readonly nsis?: NsisOptions | null
    readonly nsisWeb?: NsisWebOptions | null
    readonly portable?: PortableOptions | null
    readonly appx?: AppXOptions | null
    readonly squirrelWindows?: SquirrelWindowsOptions | null
    /**
     * Linux options.
     */
    readonly linux?: LinuxBuildOptions | null
    /**
     * Debian package specific options.
     */
    readonly deb?: DebOptions | null
    /**
     * [Snap](http://snapcraft.io) options.
     */
    readonly snap?: SnapOptions | null
    readonly appImage?: LinuxTargetSpecificOptions | null
    readonly pacman?: LinuxTargetSpecificOptions | null
    readonly rpm?: LinuxTargetSpecificOptions | null
    readonly freebsd?: LinuxTargetSpecificOptions | null
    readonly p5p?: LinuxTargetSpecificOptions | null
    readonly apk?: LinuxTargetSpecificOptions | null
    /**
     * @private
     */
    readonly icon?: string | null
    /**
     * *programmatic API only* The function to be run after pack (but before pack into distributable format and sign). Promise must be returned.
     */
    readonly afterPack?: (context: AfterPackContext) => Promise<any> | null
    /**
     * *programmatic API only* The function to be run before dependencies are installed or rebuilt. Works when `npmRebuild` is set to `true`. Promise must be returned. Resolving to `false` will skip dependencies install or rebuild.
     */
    readonly beforeBuild?: (context: BeforeBuildContext) => Promise<any> | null
  }

  export interface AfterPackContext {
    readonly outDir: string
    readonly appOutDir: string
    readonly packager: PlatformPackager<any>
    readonly electronPlatformName: string
    readonly arch: Arch
    readonly targets: Array<Target>
  }

  export interface MetadataDirectories {
    /**
     * The path to build resources.
     *
     * Please note — build resources is not packed into app. If you need to use some files, e.g. as tray icon, please include required files explicitly: `"files": ["**\/*", "build/icon.*"]`
     * @default build
     */
    readonly buildResources?: string | null
    /**
     * The output directory.
     * @default dist
     */
    readonly output?: string | null
    /**
     * The application directory (containing the application package.json), defaults to `app`, `www` or working directory.
     */
    readonly app?: string | null
  }

  /**
   * URL Protocol Schemes. Protocols to associate the app with. macOS only.
   *
   * Please note — on macOS [you need to register an `open-url` event handler](http://electron.atom.io/docs/api/app/#event-open-url-macos).
   */
  export interface Protocol {
    /**
     * The name. e.g. `IRC server URL`.
     */
    readonly name: string
    /**
     * The schemes. e.g. `["irc", "ircs"]`.
    */
    readonly schemes: Array<string>
    /**
     * *macOS-only* The app’s role with respect to the type.
     * @default Editor
     */
    readonly role?: "Editor" | "Viewer" | "Shell" | "None"
  }

  /**
   * File associations.
   *
   * macOS (corresponds to [CFBundleDocumentTypes](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-101685)) and NSIS only.
   *
   * On Windows works only if [nsis.perMachine](https://github.com/electron-userland/electron-builder/wiki/Options#NsisOptions-perMachine) is set to `true`.
   */
  export interface FileAssociation {
    /**
     * The extension (minus the leading period). e.g. `png`.
     */
    readonly ext: string | Array<string>
    /**
     * The name. e.g. `PNG`. Defaults to `ext`.
     */
    readonly name?: string | null
    /**
     * *windows-only.* The description.
     */
    readonly description?: string | null
    /**
     * The path to icon (`.icns` for MacOS and `.ico` for Windows), relative to `build` (build resources directory). Defaults to `${firstExt}.icns`/`${firstExt}.ico` (if several extensions specified, first is used) or to application icon.
     */
    readonly icon?: string | null
    /**
     * *macOS-only* The app’s role with respect to the type. The value can be `Editor`, `Viewer`, `Shell`, or `None`. Corresponds to `CFBundleTypeRole`.
     * @default Editor
     */
    readonly role?: string
    /**
     * *macOS-only* Whether the document is distributed as a bundle. If set to true, the bundle directory is treated as a file. Corresponds to `LSTypeIsPackage`.
     */
    readonly isPackage?: boolean
  }

  export interface PlatformSpecificBuildOptions extends TargetSpecificOptions {
    readonly files?: Array<FilePattern | string> | FilePattern | string | null
    readonly extraFiles?: Array<FilePattern | string> | FilePattern | string | null
    readonly extraResources?: Array<FilePattern | string> | FilePattern | string | null
    readonly asarUnpack?: Array<string> | string | null
    readonly asar?: AsarOptions | boolean | null
    readonly target?: Array<string | TargetConfig> | string | TargetConfig | null
    readonly icon?: string | null
    readonly fileAssociations?: Array<FileAssociation> | FileAssociation
    readonly forceCodeSigning?: boolean
  }

  export interface AsarOptions extends AsarIntegrityOptions {
    /**
     * Whether to automatically unpack executables files.
     * @default true
     */
    smartUnpack?: boolean
    ordering?: string | null
  }

  export interface FilePattern {
    /**
     * The source path relative to the project directory.
     */
    from?: string
    /**
     * The destination path relative to the app's content directory for `extraFiles` and the app's resource directory for `extraResources`.
     */
    to?: string
    /**
     * The [glob patterns](#file-patterns).
     */
    filter?: Array<string> | string
  }

  export interface ReleaseInfo {
    /**
     * The release name.
     */
    releaseName?: string | null
    /**
     * The release notes.
     */
    releaseNotes?: string | null
    /**
     * The path to release notes file. Defaults to `release-notes.md` in the [build resources](#MetadataDirectories-buildResources).
     */
    releaseNotesFile?: string | null
    /**
     * The release date.
     */
    releaseDate?: string
  }

  export interface ElectronDownloadOptions {
    /**
     * The [cache location](https://github.com/electron-userland/electron-download#cache-location).
     */
    cache?: string | null
    /**
     * The mirror.
     */
    mirror?: string | null
    customDir?: string | null
    customFilename?: string | null
    quiet?: boolean
    strictSSL?: boolean
    verifyChecksum?: boolean
    force?: boolean
    symbols?: boolean
    mksnapshot?: boolean
    ffmpeg?: boolean
    dsym?: boolean
  }
}

declare module "electron-builder/out/options/macOptions" {
  import { TargetConfig, TargetSpecificOptions } from "electron-builder/out/core"
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"
  export type MacOsTargetName = "default" | "dmg" | "mas" | "mas-dev" | "pkg" | "7z" | "zip" | "tar.xz" | "tar.lz" | "tar.gz" | "tar.bz2" | "dir"

  export interface MacOptions extends PlatformSpecificBuildOptions {
    /**
     * The application category type, as shown in the Finder via *View -> Arrange by Application Category* when viewing the Applications directory.
     *
     * For example, `"category": "public.app-category.developer-tools"` will set the application category to *Developer Tools*.
     *
     * Valid values are listed in [Apple's documentation](https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-SW8).
     */
    readonly category?: string | null
    /**
     * The target package type: list of `default`, `dmg`, `mas`, `pkg`, `7z`, `zip`, `tar.xz`, `tar.lz`, `tar.gz`, `tar.bz2`, `dir`. Defaults to `default` (dmg and zip for Squirrel.Mac).
    */
    readonly target?: Array<MacOsTargetName | TargetConfig> | MacOsTargetName | TargetConfig | null
    /**
     * The name of certificate to use when signing. Consider using environment variables [CSC_LINK or CSC_NAME](https://github.com/electron-userland/electron-builder/wiki/Code-Signing) instead of specifying this option.
     * MAS installer identity is specified in the [mas](#MasBuildOptions-identity).
     */
    readonly identity?: string | null
    /**
     * The path to application icon.
     * @default build/icon.icns
     */
    readonly icon?: string | null
    /**
     * The path to entitlements file for signing the app. `build/entitlements.mac.plist` will be used if exists (it is a recommended way to set).
     * MAS entitlements is specified in the [mas](#MasBuildOptions-entitlements).
     */
    readonly entitlements?: string | null
    /**
     * The path to child entitlements which inherit the security settings for signing frameworks and bundles of a distribution. `build/entitlements.mac.inherit.plist` will be used if exists (it is a recommended way to set).
     * Otherwise [default](https://github.com/electron-userland/electron-osx-sign/blob/master/default.entitlements.darwin.inherit.plist).
     *
     * This option only applies when signing with `entitlements` provided.
     */
    readonly entitlementsInherit?: string | null
    /**
     * The `CFBundleVersion`. Do not use it unless [you need to](https://github.com/electron-userland/electron-builder/issues/565#issuecomment-230678643).
     */
    readonly bundleVersion?: string | null
    /**
     * The bundle identifier to use in the application helper's plist.
     * @default ${appBundleIdentifier}.helper
     */
    readonly helperBundleId?: string | null
    /**
     * Whether to sign app for development or for distribution.
     * @default distribution
     */
    readonly type?: "distribution" | "development" | null
    /**
     * The extra entries for `Info.plist`.
     */
    readonly extendInfo?: any
    /**
     * Paths of any extra binaries that need to be signed.
     */
    readonly binaries?: Array<string> | null
    /**
     * Path of [requirements file](https://developer.apple.com/library/mac/documentation/Security/Conceptual/CodeSigningGuide/RequirementLang/RequirementLang.html) used in signing. Not applicable for MAS.
     */
    readonly requirements?: string | null
  }

  /**
   * macOS product archive options.
   */
  export interface PkgOptions extends TargetSpecificOptions {
    /**
     * The scripts directory, relative to `build` (build resources directory).
     * The scripts can be in any language so long as the files are marked executable and have the appropriate shebang indicating the path to the interpreter.
     * Scripts are required to be executable (`chmod +x file`).
     * @default build/pkg-scripts
     * @see [Scripting in installer packages](http://macinstallers.blogspot.de/2012/07/scripting-in-installer-packages.html).
     */
    readonly scripts?: string | null
    /**
     * should be not documented, only to experiment
     * @private
     */
    readonly productbuild?: Array<string> | null
    /**
     * The install location. [Do not use it](https://stackoverflow.com/questions/12863944/how-do-you-specify-a-default-install-location-to-home-with-pkgbuild) to create per-user package.
     * Mostly never you will need to change this option. `/Applications` would install it as expected into `/Applications` if the local system domain is chosen, or into `$HOME/Applications` if the home installation is chosen.
     * @default /Applications
     */
    readonly installLocation?: string | null
    /**
     * Whether can be installed at the root of any volume, including non-system volumes. Otherwise, it cannot be installed at the root of a volume.
     *
     * Corresponds to [enable_anywhere](https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/DistributionDefinitionRef/Chapters/Distribution_XML_Ref.html#//apple_ref/doc/uid/TP40005370-CH100-SW70).
     * @default true
     */
    readonly allowAnywhere?: boolean | null
    /**
     * Whether can be installed into the current user’s home directory.
     * A home directory installation is done as the current user (not as root), and it cannot write outside of the home directory.
     * If the product cannot be installed in the user’s home directory and be not completely functional from user’s home directory.
     *
     * Corresponds to [enable_currentUserHome](https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/DistributionDefinitionRef/Chapters/Distribution_XML_Ref.html#//apple_ref/doc/uid/TP40005370-CH100-SW70).
     * @default true
     */
    readonly allowCurrentUserHome?: boolean | null
    /**
     * Whether can be installed into the root directory. Should usually be `true` unless the product can be installed only to the user’s home directory.
     *
     * Corresponds to [enable_localSystem](https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/DistributionDefinitionRef/Chapters/Distribution_XML_Ref.html#//apple_ref/doc/uid/TP40005370-CH100-SW70).
     * @default true
     */
    readonly allowRootDirectory?: boolean | null
    /**
     * The name of certificate to use when signing. Consider using environment variables [CSC_LINK or CSC_NAME](https://github.com/electron-userland/electron-builder/wiki/Code-Signing) instead of specifying this option.
     */
    readonly identity?: string | null
  }

  export interface DmgOptions extends TargetSpecificOptions {
    /**
     * The path to background image (default: `build/background.tiff` or `build/background.png` if exists). The resolution of this file determines the resolution of the installer window.
     * If background is not specified, use `window.size`. Default locations expected background size to be 540x380.
     * @see [DMG with Retina background support](http://stackoverflow.com/a/11204769/1910191).
     */
    readonly background?: string | null
    /**
     * The background color (accepts css colors). Defaults to `#ffffff` (white) if no background image.
     */
    readonly backgroundColor?: string | null
    /**
     * The path to DMG icon (volume icon), which will be shown when mounted, relative to the the [build resources](https://github.com/electron-userland/electron-builder/wiki/Options#MetadataDirectories-buildResources) or to the project directory.
     * Defaults to the application icon (`build/icon.icns`).
     */
    readonly icon?: string | null
    /**
     * The size of all the icons inside the DMG.
     * @default 80
     */
    readonly iconSize?: number | null
    /**
     * The size of all the icon texts inside the DMG.
     * @default 12
     */
    readonly iconTextSize?: number | null
    /**
     * The title of the produced DMG, which will be shown when mounted (volume name).
     *
     * Macro `${productName}`, `${version}` and `${name}` are supported.
     * @default ${productName} ${version}
     */
    readonly title?: string | null
    /**
     * The content — to customize icon locations.
     */
    readonly contents?: Array<DmgContent>
    /**
     * The disk image format. `ULFO` (lzfse-compressed image (OS X 10.11+ only)).
     * @default UDZO
     */
    readonly format?: "UDRW" | "UDRO" | "UDCO" | "UDZO" | "UDBZ" | "ULFO"
    /**
     * The DMG windows position and size.
     */
    window?: DmgWindow
  }

  export interface DmgWindow {
    /**
     * The X position relative to left of the screen.
     * @default 400
     */
    x?: number
    /**
     * The Y position relative to top of the screen.
     * @default 100
     */
    y?: number
    /**
     * The width. Defaults to background image width or 540.
     */
    width?: number
    /**
     * The height. Defaults to background image height or 380.
     */
    height?: number
  }

  export interface DmgContent {
    x: number
    y: number
    type?: "link" | "file"
    /**
     * The name of the file within the DMG. Defaults to basename of `path`.
     */
    name?: string
    path?: string
  }

  export interface MasBuildOptions extends MacOptions {
    /**
     * The path to entitlements file for signing the app. `build/entitlements.mas.plist` will be used if exists (it is a recommended way to set).
     * Otherwise [default](https://github.com/electron-userland/electron-osx-sign/blob/master/default.entitlements.mas.plist).
     */
    readonly entitlements?: string | null
    /**
     * The path to child entitlements which inherit the security settings for signing frameworks and bundles of a distribution. `build/entitlements.mas.inherit.plist` will be used if exists (it is a recommended way to set).
     * Otherwise [default](https://github.com/electron-userland/electron-osx-sign/blob/master/default.entitlements.mas.inherit.plist).
     */
    readonly entitlementsInherit?: string | null
    /**
     * Paths of any extra binaries that need to be signed.
     */
    readonly binaries?: Array<string> | null
  }
}

declare module "electron-builder/out/targets/dmg" {
  import { Arch, Target } from "electron-builder/out/core"
  import { DmgOptions, MacOptions } from "electron-builder/out/options/macOptions"
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  export class DmgTarget extends Target {
    private readonly packager
    readonly outDir: string
    readonly options: DmgOptions
    private helperDir
    constructor(packager: PlatformPackager<MacOptions>, outDir: string)
    build(appPath: string, arch: Arch): Promise<void>
    computeVolumeName(custom?: string | null): string
    computeDmgOptions(): Promise<DmgOptions>
  }

  export function attachAndExecute(dmgPath: string, readWrite: boolean, task: () => Promise<any>): Promise<any>
}

declare module "electron-builder/out/targets/pkg" {
  import { Identity } from "electron-builder/out/codeSign"
  import { Arch, Target } from "electron-builder/out/core"
  import MacPackager from "electron-builder/out/macPackager"
  import { PkgOptions } from "electron-builder/out/options/macOptions"

  export class PkgTarget extends Target {
    private readonly packager
    readonly outDir: string
    readonly options: PkgOptions
    constructor(packager: MacPackager, outDir: string)
    build(appPath: string, arch: Arch): Promise<any>
    private customizeDistributionConfiguration(distInfoFile, appPath)
    private buildComponentPackage(appPath, outFile)
  }

  export function prepareProductBuildArgs(identity: Identity | null, keychain: string | null | undefined): Array<string>
}

declare module "electron-builder/out/util/bundledTool" {
  export const EXEC_TIMEOUT: {
    timeout: number
  }

  /** @private */
  export function getLinuxToolsPath(): Promise<string>
}

declare module "electron-builder/out/targets/archive" {
  
  export interface ArchiveOptions {
    /**
     * @default false
     */
    withoutDir?: boolean
    /**
     * @default true
     */
    solid?: boolean
    listFile?: string
    dictSize?: number
    excluded?: Array<string>
    method?: "Copy" | "LZMA"
  }
}

declare module "electron-builder/out/targets/ArchiveTarget" {
  import { Arch, Target } from "electron-builder/out/core"
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  export class ArchiveTarget extends Target {
    readonly outDir: string
    private readonly packager
    readonly options: any
    constructor(name: string, outDir: string, packager: PlatformPackager<any>)
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/targets/targetFactory" {
  import { Arch, Platform, Target } from "electron-builder/out/core"
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  export function computeArchToTargetNamesMap(raw: Map<Arch, Array<string>>, options: PlatformSpecificBuildOptions, platform: Platform): Map<Arch, Array<string>>

  export function createTargets(nameToTarget: Map<string, Target>, rawList: Array<string>, outDir: string, packager: PlatformPackager<any>): Array<Target>

  export function createCommonTarget(target: string, outDir: string, packager: PlatformPackager<any>): Target

  export class NoOpTarget extends Target {
    readonly options: null
    constructor(name: string)
    readonly outDir: string
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/macPackager" {
  import { SignOptions } from "electron-osx-sign"
  import { AppInfo } from "electron-builder/out/appInfo"
  import { CodeSigningInfo, Identity } from "electron-builder/out/codeSign"
  import { Arch, Platform, Target } from "electron-builder/out/core"
  import { MacOptions } from "electron-builder/out/options/macOptions"
  import { Packager } from "electron-builder/out/packager"
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { AsyncTaskManager } from "electron-builder/out/util/asyncTaskManager"

  export default class MacPackager extends PlatformPackager<MacOptions> {
    readonly codeSigningInfo: Promise<CodeSigningInfo>
    constructor(info: Packager)
    readonly defaultTarget: Array<string>
    protected prepareAppInfo(appInfo: AppInfo): AppInfo
    getIconPath(): Promise<string | null>
    createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void): void
    readonly platform: Platform
    pack(outDir: string, arch: Arch, targets: Array<Target>, taskManager: AsyncTaskManager): Promise<any>
    private sign(appPath, outDir, masOptions)
    private reportError(isMas, certificateType, qualifier, keychainName)
    private adjustSignOptions(signOptions, masOptions)
    protected doSign(opts: SignOptions): Promise<any>
    protected doFlat(appPath: string, outFile: string, identity: Identity, keychain: string | n): Promise<any>
    getElectronSrcDir(dist: string): string
    getElectronDestinationDir(appOutDir: string): string
  }
}

declare module "electron-builder/out/util/repositoryInfo" {
  import { SourceRepositoryInfo } from "electron-builder/out/core"
  import { Metadata } from "electron-builder/out/metadata"

  export function getRepositoryInfo(projectDir: string, metadata?: Metadata, devMetadata?: Metadata): Promise<SourceRepositoryInfo | null>
}

declare module "electron-builder/out/util/yarn" {
  import { Lazy } from "electron-builder-util"
  import { Dependency } from "electron-builder/out/util/packageDependencies"

  export interface RebuildOptions {
    frameworkInfo: DesktopFrameworkInfo
    productionDeps?: Lazy<Array<Dependency>>
    platform?: string
    arch?: string
    buildFromSource?: boolean
    additionalArgs?: Array<string> | null
  }
}

declare module "electron-builder/out/windowsCodeSign" {
  import { WinBuildOptions } from "electron-builder/out/options/winOptions"

  export interface SignOptions {
    readonly path: string
    readonly cert?: string | null
    readonly name?: string | null
    readonly password?: string | null
    readonly site?: string | null
    readonly options: WinBuildOptions
  }
}

declare module "electron-builder/out/targets/appx" {
  import { Arch, Target } from "electron-builder/out/core"
  import { AppXOptions } from "electron-builder/out/options/winOptions"
  import { WinPackager } from "electron-builder/out/winPackager"

  export default class AppXTarget extends Target {
    private readonly packager
    readonly outDir: string
    readonly options: AppXOptions
    constructor(packager: WinPackager, outDir: string)
    build(appOutDir: string, arch: Arch): Promise<any>
    private writeManifest(templatePath, preAppx, arch, publisher, userAssets)
  }

  export function quoteString(s: string): string
}

declare module "electron-builder/out/util/timer" {
  
  export interface Timer {
    end(): void
  }

  export function time(label: string): Timer
}

declare module "electron-builder/out/util/wine" {
  import { ExecOptions } from "electron-builder-util"

  /** @private */
  export function execWine(file: string, args: Array<string>, options?: ExecOptions): Promise<string>

  /** @private */
  export function prepareArgs(args: Array<string>, exePath: string): string[]

  /** @private */
  export function checkWineVersion(checkPromise: Promise<string>): Promise<void>
}

declare module "electron-builder/out/targets/blockMap" {
  
  export function computeBlockMap(appOutDir: string): Promise<string>
}

declare module "electron-builder/out/targets/nsis/nsisUtil" {
  import { Arch } from "electron-builder/out/core"
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { NsisTarget } from "electron-builder/out/nsis"
  export const nsisTemplatesDir: string

  export class AppPackageHelper {
    private readonly archToFileInfo
    private readonly infoToIsDelete
    /** @private */
    refCount: number
    packArch(arch: Arch, target: NsisTarget): Promise<string>
    finishBuild(): Promise<any>
  }

  export function addCustomMessageFileInclude(input: string, packager: PlatformPackager<any>, isUnicodeEnabled: boolean): Promise<string>
}

declare module "electron-builder/out/targets/nsis" {
  import { Arch, Target } from "electron-builder/out/core"
  import { NsisOptions } from "electron-builder/out/options/winOptions"
  import { WinPackager } from "electron-builder/out/winPackager"
  import { AppPackageHelper } from "electron-builder/out/targets/nsis/nsisUtil"

  export class NsisTarget extends Target {
    protected readonly packager: WinPackager
    readonly outDir: string
    protected readonly packageHelper: AppPackageHelper
    readonly options: NsisOptions
    /** @private */
    readonly archs: Map<Arch, string>
    constructor(packager: WinPackager, outDir: string, targetName: string, packageHelper: AppPackageHelper)
    build(appOutDir: string, arch: Arch): Promise<void>
    /** @private */
    buildAppPackage(appOutDir: string, arch: Arch): Promise<string>
    finishBuild(): Promise<any>
    protected readonly installerFilenamePattern: string
    private readonly isPortable
    private buildInstaller()
    protected generateGitHubInstallerName(): string
    private readonly isUnicodeEnabled
    readonly isWebInstaller: boolean
    private computeScriptAndSignUninstaller(defines, commands, installerPath)
    private computeVersionKey()
    protected configureDefines(oneClick: boolean, defines: any): Promise<void>
    private configureDefinesForAllTypeOfInstaller(defines)
    private executeMakensis(defines, commands, script)
    private computeFinalScript(originalScript, isInstaller)
    private computeLicensePage()
  }
}

declare module "electron-builder/out/publish/PublishManager" {
  import { CancellationToken } from "electron-builder-http"
  import { PublishConfiguration } from "electron-builder-http/out/publishOptions"
  import { PublishContext, Publisher, PublishOptions } from "electron-publish"
  import { MultiProgress } from "electron-publish/out/multiProgress"
  import { Arch } from "electron-builder/out/core"
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"
  import { Packager } from "electron-builder/out/packager"
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  export class PublishManager implements PublishContext {
    private readonly publishOptions
    readonly cancellationToken: CancellationToken
    private readonly nameToPublisher
    private readonly taskManager
    private readonly isPublish
    readonly progress: MultiProgress | null
    constructor(packager: Packager, publishOptions: PublishOptions, cancellationToken: CancellationToken)
    private artifactCreated(event)
    private getOrCreatePublisher(publishConfig, platformPackager)
    cancelTasks(): void
    awaitTasks(): Promise<any[]>
  }

  export function getPublishConfigsForUpdateInfo(packager: PlatformPackager<any>, publishConfigs: Array<PublishConfiguration> | null, arch: Arch | null): Promise<Array<PublishConfiguration> | null>

  export function createPublisher(context: PublishContext, version: string, publishConfig: PublishConfiguration, options: PublishOptions): Publisher | null

  export function computeDownloadUrl(publishConfig: PublishConfiguration, fileName: string | null, packager: PlatformPackager<any>): string

  export function getPublishConfigs(packager: PlatformPackager<any>, targetSpecificOptions: PlatformSpecificBuildOptions | null | undefined, arch: Arch | null): Promise<Array<PublishConfiguration> | null>
}

declare module "electron-builder/out/targets/nsis/WebInstallerTarget" {
  import { WinPackager } from "electron-builder/out/../winPackager"
  import { NsisTarget } from "electron-builder/out/targets/nsis"
  import { AppPackageHelper } from "electron-builder/out/targets/nsis/nsisUtil"

  /** @private */
  export class WebInstallerTarget extends NsisTarget {
    constructor(packager: WinPackager, outDir: string, targetName: string, packageHelper: AppPackageHelper)
    readonly isWebInstaller: boolean
    protected configureDefines(oneClick: boolean, defines: any): Promise<void>
    protected readonly installerFilenamePattern: string
    protected generateGitHubInstallerName(): string
  }
}

declare module "electron-builder/out/util/cacheManager" {
  /// <reference types="node" />
  import { Hash } from "crypto"
  import { Arch } from "electron-builder/out/core"

  export interface BuildCacheInfo {
    executableDigest: string
  }

  export class BuildCacheManager {
    private readonly executableFile
    static VERSION: string
    readonly cacheDir: string
    readonly cacheInfoFile: string
    readonly cacheFile: string
    cacheInfo: BuildCacheInfo | null
    private newDigest
    constructor(outDir: string, executableFile: string, arch: Arch)
    copyIfValid(digest: string): Promise<boolean>
    save(): Promise<void>
  }

  export function digest(hash: Hash, files: Array<string>): Promise<string>
}

declare module "electron-builder/out/winPackager" {
  import { Lazy } from "electron-builder-util"
  import { Arch, Platform, Target } from "electron-builder/out/core"
  import { AfterPackContext } from "electron-builder/out/metadata"
  import { WinBuildOptions } from "electron-builder/out/options/winOptions"
  import { Packager } from "electron-builder/out/packager"
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { FileCodeSigningInfo, SignOptions } from "electron-builder/out/windowsCodeSign"

  export class WinPackager extends PlatformPackager<WinBuildOptions> {
    readonly cscInfo: Lazy<FileCodeSigningInfo | null>
    private _iconPath
    readonly computedPublisherSubjectOnWindowsOnly: Lazy<string | null>
    readonly computedPublisherName: Lazy<string[] | null>
    readonly isForceCodeSigningVerification: boolean
    constructor(info: Packager)
    readonly defaultTarget: Array<string>
    protected doGetCscPassword(): string | undefined
    createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void): void
    readonly platform: Platform
    getIconPath(): Promise<string | null>
    private getValidIconPath()
    sign(file: string, logMessagePrefix?: string): Promise<void>
    protected doSign(options: SignOptions): Promise<void>
    signAndEditResources(file: string, arch: Arch, outDir: string): Promise<void>
    protected postInitApp(packContext: AfterPackContext): Promise<void>
    protected signApp(packContext: AfterPackContext): Promise<any>
  }
}

declare module "electron-builder/out/packager" {
  /// <reference types="node" />
  import { CancellationToken } from "electron-builder-http"
  import { Lazy, TmpDir } from "electron-builder-util"
  import { EventEmitter } from "events"
  import { AppInfo } from "electron-builder/out/appInfo"
  import { Platform, SourceRepositoryInfo, Target } from "electron-builder/out/core"
  import { AfterPackContext, Config, Metadata } from "electron-builder/out/metadata"
  import { ArtifactCreated, PackagerOptions } from "electron-builder/out/packagerApi"
  import { Dependency } from "electron-builder/out/util/packageDependencies"

  export class Packager {
    readonly cancellationToken: CancellationToken
    readonly projectDir: string
    appDir: string
    metadata: Metadata
    private _isPrepackedAppAsar
    readonly isPrepackedAppAsar: boolean
    private devMetadata
    private _config
    readonly config: Config
    isTwoPackageJsonProjectLayoutUsed: boolean
    readonly eventEmitter: EventEmitter
    appInfo: AppInfo
    readonly tempDirManager: TmpDir
    private _repositoryInfo
    private readonly afterPackHandlers
    readonly options: PackagerOptions
    readonly repositoryInfo: Promise<SourceRepositoryInfo | null>
    private _productionDeps
    readonly productionDeps: Lazy<Array<Dependency>>
    constructor(options: PackagerOptions, cancellationToken: CancellationToken)
    addAfterPackHandler(handler: (context: AfterPackContext) => Promise<any> | null): void
    artifactCreated(handler: (event: ArtifactCreated) => void): Packager
    dispatchArtifactCreated(event: ArtifactCreated): void
    build(): Promise<BuildResult>
    private readProjectMetadataIfTwoPackageStructureOrPrepacked(appPackageFile)
    private doBuild(outDir)
    private createHelper(platform)
    private installAppDependencies(platform, arch)
    afterPack(context: AfterPackContext): Promise<void>
  }

  export function normalizePlatforms(rawPlatforms: Array<string | Platform> | string | Platform | n): Array<Platform>

  export interface BuildResult {
    readonly outDir: string
    readonly platformToTargets: Map<Platform, Map<string, Target>>
  }
}

declare module "electron-builder/out/appInfo" {
  import { Packager } from "electron-builder/out/packager"

  export class AppInfo {
    private readonly info
    readonly description: string
    readonly version: string
    readonly buildNumber: string | undefined
    readonly buildVersion: string
    readonly productName: string
    readonly productFilename: string
    constructor(info: Packager, buildVersion?: string | null)
    readonly channel: string | null
    readonly versionInWeirdWindowsForm: string
    readonly companyName: string | null
    readonly id: string
    readonly name: string
    readonly copyright: string
    computePackageUrl(): Promise<string | null>
  }
}

declare module "electron-builder/out/builder" {
  import { PublishOptions } from "electron-publish"
  import { Arch, Platform } from "electron-builder/out/core"
  import { PackagerOptions } from "electron-builder/out/packagerApi"

  export interface CliOptions extends PackagerOptions, PublishOptions {
    mac?: Array<string>
    linux?: Array<string>
    win?: Array<string>
    arch?: string
    x64?: boolean
    ia32?: boolean
    armv7l?: boolean
    dir?: boolean
    platform?: string
    project?: string
    extraMetadata?: any
  }

  /** @private */
  export function coerceTypes(host: any): any

  export function createTargets(platforms: Array<Platform>, type?: string | null, arch?: string | null): Map<Platform, Map<Arch, Array<string>>>

  export function build(rawOptions?: CliOptions): Promise<Array<string>>
}

declare module "electron-builder/out/errorMessages" {
  export const authorEmailIsMissed: string
}

declare module "electron-builder/out/forge/forge-maker" {
  import { CliOptions } from "electron-builder/out/builder"

  export interface ForgeOptions {
    readonly dir: string
  }

  export function buildForge(forgeOptions: ForgeOptions, options: CliOptions): Promise<string[]>
}

declare module "electron-builder" {
  export { Packager, BuildResult } from "electron-builder/out/packager"
  export { PackagerOptions, ArtifactCreated } from "electron-builder/out/packagerApi"
  export { getArchSuffix, Platform, Arch, archFromString, Target, DIR_TARGET } from "electron-builder/out/core"
  export { build, CliOptions, createTargets } from "electron-builder/out/builder"
  export { Metadata, Config, AfterPackContext, MetadataDirectories, Protocol, FileAssociation, PlatformSpecificBuildOptions, AuthorMetadata, RepositoryInfo, AsarOptions, FilePattern, ReleaseInfo, ElectronDownloadOptions } from "electron-builder/out/metadata"
  export { MacOptions, DmgOptions, MasBuildOptions, MacOsTargetName, PkgOptions, DmgContent, DmgWindow } from "electron-builder/out/options/macOptions"
  export { WinBuildOptions, NsisOptions, SquirrelWindowsOptions, AppXOptions, NsisWebOptions, PortableOptions, CommonNsisOptions } from "electron-builder/out/options/winOptions"
  export { LinuxBuildOptions, DebOptions, SnapOptions, CommonLinuxOptions, LinuxTargetSpecificOptions } from "electron-builder/out/options/linuxOptions"
  export { buildForge, ForgeOptions } from "electron-builder/out/forge/forge-maker"
}

declare module "electron-builder/out/targets/LinuxTargetHelper" {
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  import { LinuxBuildOptions, LinuxTargetSpecificOptions } from "electron-builder/out/options/linuxOptions"
  export const installPrefix = "/opt"

  export class LinuxTargetHelper {
    private packager
    readonly icons: Promise<Array<Array<string>>>
    maxIconPath: string | null
    constructor(packager: LinuxPackager)
    private computeDesktopIcons()
    private iconsFromDir(iconDir)
    private getIcns()
    getDescription(options: LinuxBuildOptions): string
    computeDesktopEntry(targetSpecificOptions: LinuxTargetSpecificOptions, exec?: string, destination?: string | null, extra?: {
      [key: string]: string
    }): Promise<string>
    private createFromIcns(tempDir)
    private createMappings(tempDir)
  }
}

declare module "electron-builder/out/targets/appImage" {
  import { Arch, Target } from "electron-builder/out/core"
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  import { LinuxBuildOptions } from "electron-builder/out/options/linuxOptions"
  import { LinuxTargetHelper } from "electron-builder/out/targets/LinuxTargetHelper"

  export default class AppImageTarget extends Target {
    private readonly packager
    private readonly helper
    readonly outDir: string
    readonly options: LinuxBuildOptions
    private readonly desktopEntry
    constructor(ignored: string, packager: LinuxPackager, helper: LinuxTargetHelper, outDir: string)
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/targets/fpm" {
  import { Arch, Target } from "electron-builder/out/core"
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  import { LinuxTargetSpecificOptions } from "electron-builder/out/options/linuxOptions"
  import { LinuxTargetHelper } from "electron-builder/out/targets/LinuxTargetHelper"

  export default class FpmTarget extends Target {
    private readonly packager
    private readonly helper
    readonly outDir: string
    readonly options: LinuxTargetSpecificOptions
    private readonly scriptFiles
    constructor(name: string, packager: LinuxPackager, helper: LinuxTargetHelper, outDir: string)
    private createScripts()
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/targets/snap" {
  import { Arch, Target } from "electron-builder/out/core"
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  import { SnapOptions } from "electron-builder/out/options/linuxOptions"
  import { LinuxTargetHelper } from "electron-builder/out/targets/LinuxTargetHelper"

  export default class SnapTarget extends Target {
    private readonly packager
    private readonly helper
    readonly outDir: string
    readonly options: SnapOptions
    constructor(name: string, packager: LinuxPackager, helper: LinuxTargetHelper, outDir: string)
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/linuxPackager" {
  import { Platform, Target } from "electron-builder/out/core"
  import { AfterPackContext } from "electron-builder/out/metadata"
  import { LinuxBuildOptions } from "electron-builder/out/options/linuxOptions"
  import { Packager } from "electron-builder/out/packager"
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  export class LinuxPackager extends PlatformPackager<LinuxBuildOptions> {
    readonly executableName: string
    constructor(info: Packager)
    readonly defaultTarget: Array<string>
    createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void): void
    readonly platform: Platform
    protected postInitApp(packContext: AfterPackContext): Promise<any>
  }
}

